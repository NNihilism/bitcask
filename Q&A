1. logentryid如何统一且唯一
    logentryid由主节点生成，其他节点不负责生成id，因此不会出现不统一的问题。
    在生成logentryid时使用锁来进行互斥操作即可保证id唯一
    
2. 如何知道slave准备好接受全量复制?
    slave->master 请求复制
    master->slave 告知复制类型
    如若进行增量复制，则master节点直接开始数据传输
    如若进行全量复制，则master需要等待slave再次发送请求，即
        slave->master 告知做好准备
        master->slave 开始发送数据

3. 全量复制时,如果有新的写操作怎么办? 
    全量复制时,因为bitcask没有快照功能,所以使用全局锁，来保证其他请求不对数据库内容进行操作，接着扫描所有合法的k-v,再释放全局锁，因此新来的写请求不会被写入快照中
    其次，扫描出的k-v，会交由并发协程异步发送，因此扫描完快照后，新的写请求就可以在Master节点正常写入
    该写请求，不会被马上同步至slave节点，而是写入缓冲区，，待全量复制完成，再将缓冲区刷新

4. 刷新缓冲区的过程中又有数据想写入缓冲区怎么办？
    刷新缓冲区时，该缓冲区会被上锁（slice不是并发安全的），因此新的写请求会被阻塞，待缓冲区刷新完毕后，该写请求会发现缓冲区不可用，因此进行命令传播，即直接发送给对应的slave节点。
    
5. 增量复制时，如果有新的写请求怎么办？
    主节点正常写入，但不会马上同步给slave节点，而是由负责增量复制的协程来将新的写请求写入

6. 全量复制时,如何保证没有遗漏?
    序列号递增 + 最后确认，无误则全量复制成功，否则视为失败

7. 客户端如何记录知道节点信息是否改变？  
    定时轮询 + 时间戳


坑
waitgroup有个nocopy字段 作为参数应该使用指针操作同一份
